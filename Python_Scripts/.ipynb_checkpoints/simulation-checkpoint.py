'''
simulation.py
This file retrieves csv files generated by Netlogo Simulations from a directory, filters the data, utilizes Bayes Theory,
and KL Divergence,and exports the data into another CSV.
Created By: Kylie C
'''

from fileinput import filename
from typing import Any

import numpy as np
import pandas as pd
from numpy import ndarray, dtype
import csv
import os
import sys
import glob


def bayes_array(filename):
    # This function turn the data frame into variables from Bayes Theorem to be stored into an array

    # Read the CSV file
    df = pd.read_csv(filename)

    # Clean up column names by stripping extra spaces and quotes
    df.columns = df.columns.str.strip().str.replace('"', '')

    # Convert all data to strings for easier comparison
    str_df = df.astype(str)

    # Construct a string that matches what the header would look like in the data
    header_as_str = [str(col) for col in df.columns]

    # Identify rows that match the header row
    is_header_row = (str_df == header_as_str).all(axis=1)

    # Filter out the rows that match the header
    df = df[~is_header_row]

    # Convert columns back to appropriate data types if necessary
    # For example, convert 'tick', 'turtle_id', 'freq' back to numeric if they were converted to string
    df['tick'] = pd.to_numeric(df['tick'], errors='coerce')
    df['turtle_id'] = pd.to_numeric(df['turtle_id'], errors='coerce')
    df['freq'] = pd.to_numeric(df['freq'], errors='coerce')

    # Continue with your specific processing
    # Assuming 'egg_contact_time' should be numeric
    df['egg_contact_time'] = pd.to_numeric(df['egg_contact_time'], errors='coerce')
    is_greater_than_zero = df['egg_contact_time'] > 0
    df['Egg contact?'] = is_greater_than_zero.astype(int)
    # Set printing array to a certain length
    np.set_printoptions(suppress=True, precision=6)  # precision can be adjusted as needed

    # Sum all the eggs that got in contact
    all_contact = (df['egg_contact_time'] > 0).sum()

    # Find the maximum value in the 'tick' column
    max_tick = df['tick'].max()

    # Filter the DataFrame to only include rows with the maximum 'tick' value
    df = df[df['tick'] == max_tick]

    # Define the number of rows and columns in data frame
    rows, cols = df.shape

    # Sort the df by frequency number
    df = df.sort_values(by='freq')
    # Separate all the unique freq  and how many
    unique_freq = df['freq'].unique()
    unique_freq_num = df['freq'].nunique()

    unique_freq_counts = df['freq'].value_counts()
    unique_freq_counts = unique_freq_counts.sort_index()

    # Create an empty array with the size of the unique frequency number and 6 columns
    bayes_variables: ndarray[Any, dtype[Any]] = np.zeros((unique_freq_num, 9), dtype=float)

    # Find how many sperm from each unique frequency had contact with the egg
    contact_true = df.groupby('freq')['Egg contact?'].sum()

    # Contact per a frequency divided by the number of all sperm that got in contact
    q_prime = contact_true / all_contact

    # Add frequency number index, unique frequencies, and prior to the array
    bayes_variables[:, 0] = np.arange(1, (unique_freq_num + 1))  # Index
    bayes_variables[:, 1] += unique_freq  # All the possible frequency from data
    bayes_variables[:, 2] += unique_freq_counts  # How many sperm are in each frequency
    bayes_variables[:, 3] += unique_freq_counts / rows  # The probability of each frequency on the simulation
    bayes_variables[:, 4] += q_prime
    prior = 1 / rows
    bayes_variables[:, 5] += prior  # Prior probability (the assumption all sperm have equal chance)

    # Calculate each likelihood  P( frequency | contact)
    likelihood = contact_true / unique_freq_counts
    bayes_variables[:, 6] += likelihood

    # Add the unnorm to the array
    bayes_variables[:, 7] += prior * likelihood

    # Find the total probability P(frequency) by summing all the unnorm
    total_prob = bayes_variables[:, 7].sum()

    # Find the posterior P(contact | frequency)
    bayes_variables[:, 8] += (bayes_variables[:, 7] / total_prob)
    return bayes_variables


def kl_divergence(filename):
    # This function extracts the q and q' from the file and calculates the Kullback Leibler Divergence

    # Extract the probability of each frequency on the simulation from the bayes array (q)
    data = bayes_array(filename)

    # Extract data frame to get the number of contact for each frequency / total number of sperm contact (q')
    df = pd.read_csv(filename)

    # Remove any leading/trailing spaces and extra quotes in column names
    df.columns = df.columns.str.strip().str.strip('"')

    # Find the maximum value in the 'tick' column
    max_tick = df['tick'].max()

    # Filter the DataFrame to only include rows with the maximum 'tick' value
    df = df[df['tick'] == max_tick]

    # Assuming 'egg_contact_time' should be numeric and add a boolean column for egg contact
    df['egg_contact_time'] = pd.to_numeric(df['egg_contact_time'], errors='coerce')
    is_greater_than_zero = df['egg_contact_time'] > 0
    df['Egg contact?'] = is_greater_than_zero.astype(int)

    # Find how many sperm from each unique frequency had contact with the egg
    contact_true = df.groupby('freq')['Egg contact?'].sum()

    # Sum all the eggs that got in contact
    all_contact = (df['egg_contact_time'] > 0).sum()
    q = data[:, 3]
    q_prime = contact_true / all_contact
    kl_div = 0
    for qi, q_prime_i in zip(q, q_prime):
        if q_prime_i > 0:  # Only add to the sum if q_prime_i is not zero
            kl_div += q_prime_i * np.log2(q_prime_i / qi)
            # Implicitly, if q_prime_i is 0, it adds 0 to the KL divergence, as per the condition.

    return kl_div


def write_csv(data, kl_value, filename):
    # This function saves processed data and a KL div value to a new CSV file with a modified filename

    # Prepare the output filename by inserting '_results' before '.csv'
    if filename.lower().endswith(".csv"):
        output_filename = f"{filename[:-4]}_results.csv"
    else:
        output_filename = f"{filename}_results.csv"

    with open(output_filename, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(['Frequency Types', 'Q', 'Likelihood', 'Posterior', 'KL Divergence'])

        # First row with KL divergence
        writer.writerow([
            data[0][1],  # Column 1 from the array: Frequency Types
            data[0][3],  # Column 4 from the bayes array : q
            data[0][6],  # Column 6 from the array: Likelihood
            data[0][8],  # Column 8 from the array: Posterior
            kl_value  # KL Divergence only in the first row
        ])

        # Subsequent rows without KL divergence
        for row in data[1:]:
            writer.writerow([
                row[1],  # Frequency Types
                row[3],  # Q
                row[6],  # Likelihood
                row[8],  # Posterior
                ''  # Empty for KL Divergence
            ])


def process_files(directory):
    # This function processes through the csv files in the directory and writes the computed results

    # Loops through the csv files
    for filepath in glob.glob(os.path.join(directory, '*.csv')):
        try:
            print(f"Processing file: {filepath}")

            # Process the file to get data using bayes_array function
            data = bayes_array(filepath)

            if data is None:
                continue

            # Compute the KL divergence for the file
            kl_value = kl_divergence(filepath)

            if kl_value < 0:
                print("Error: KL divergence cannot be zero: ", kl_value)

            # Write the processed data and KL divergence value to a new CSV file
            write_csv(data, kl_value, filepath)

        except Exception as e:
            print(f"Failed to process {filepath}: {e}")


if __name__ == "__main__":
    if len(sys.argv) > 1:
        input_directory = sys.argv[1]
    else:
        print("Please provide a directory path as an argument.")
        sys.exit(1)  # Exit if no directory is provided
    process_files(input_directory)
